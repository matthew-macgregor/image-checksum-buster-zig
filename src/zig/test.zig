const std = @import("std");
const img = @import("image.zig");

// https://stackoverflow.com/a/4017060
const minimal_jpeg = [_]u8{ 0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x02, 0x00, 0x00, 0x64, 0x00, 0x64, 0x00, 0x00, 0xFF, 0xEC, 0x00, 0x11, 0x44, 0x75, 0x63, 0x6B, 0x79, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xEE, 0x00, 0x0E, 0x41, 0x64, 0x6F, 0x62, 0x65, 0x00, 0x64, 0xC0, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xDB, 0x00, 0x84, 0x00, 0x1B, 0x1A, 0x1A, 0x29, 0x1D, 0x29, 0x41, 0x26, 0x26, 0x41, 0x42, 0x2F, 0x2F, 0x2F, 0x42, 0x47, 0x3F, 0x3E, 0x3E, 0x3F, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x01, 0x1D, 0x29, 0x29, 0x34, 0x26, 0x34, 0x3F, 0x28, 0x28, 0x3F, 0x47, 0x3F, 0x35, 0x3F, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x08, 0x00, 0x19, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xFF, 0xC4, 0x00, 0x61, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x05, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x10, 0x00, 0x02, 0x02, 0x02, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x11, 0x03, 0x00, 0x41, 0x21, 0x12, 0xF0, 0x13, 0x04, 0x31, 0x11, 0x00, 0x01, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x31, 0x61, 0x71, 0xB1, 0x12, 0x22, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0xA1, 0x7E, 0x6B, 0xAD, 0x4E, 0xB6, 0x4B, 0x30, 0xEA, 0xE0, 0x19, 0x82, 0x39, 0x91, 0x3A, 0x6E, 0x63, 0x5F, 0x99, 0x8A, 0x68, 0xB6, 0xE3, 0xEA, 0x70, 0x08, 0xA8, 0x00, 0x55, 0x98, 0xEE, 0x48, 0x22, 0x37, 0x1C, 0x63, 0x19, 0xAF, 0xA5, 0x68, 0xB8, 0x05, 0x24, 0x9A, 0x7E, 0x99, 0xF5, 0xB3, 0x22, 0x20, 0x55, 0xEA, 0x27, 0xCD, 0x8C, 0xEB, 0x4E, 0x31, 0x91, 0x9D, 0x41, 0xFF, 0xD9 };
const debug = false;
const test_dir_path = "_test_img";
const sep = std.fs.path.sep_str;

fn createMinimalJpeg(path: []const u8) !void {
    try createAnyFile(path, &minimal_jpeg);
}

fn createAnyFile(path: []const u8, buffer: []const u8) !void {
    const file = try std.fs.cwd().createFile(path, .{});
    defer file.close();
    try file.writeAll(buffer);
}

fn slurpFile(alloc: std.mem.Allocator, path: []const u8) ![]u8 {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();
    const stat = try file.stat();
    const buffer = try alloc.alloc(u8, stat.size);
    const bytes_read = try file.readAll(buffer);
    if (debug) std.debug.print("bytes read: {d}\n", .{bytes_read});
    return buffer;
}

fn md5File(alloc: std.mem.Allocator, path: []const u8, hash_out: *[16]u8) !void {
    const buffer = try slurpFile(alloc, path);
    defer alloc.free(buffer);
    var h = std.crypto.hash.Md5.init(.{});
    h.update(buffer);
    h.final(hash_out);
}

fn setup() !void {
    const p = test_dir_path ++ sep ++ "minimal.jpg";
    std.fs.cwd().makeDir(test_dir_path) catch |err| {
        if (debug) std.debug.print("\nDirectory already exists: {any}.\n", .{err});
    };
    try createMinimalJpeg(p);
}

fn teardown() !void {
    if (std.mem.startsWith(u8, test_dir_path, sep)) {
        std.debug.print("!!!! {s} may be dangerous!\n", .{test_dir_path});
        return;
    }
    std.fs.cwd().deleteTree(test_dir_path) catch |err| {
        if (debug) std.debug.print("\nFailed to clean up the test dir: {any}.\n", .{err});
    };
}

test "icbust_file" {
    const filen_in = test_dir_path ++ sep ++ "minimal.jpg";
    const filen_out = test_dir_path ++ sep ++ "minimal_out.jpg";
    try setup();
    try img.icbustFile(filen_in, filen_out, debug);
}

test "icbust_file with bad file" {
    const filen_in = test_dir_path ++ sep ++ "bad.txt";
    const filen_out = "won't matter";
    try setup();
    try createAnyFile(filen_in, &[_]u8{ 0x35, 0x36 });
    img.icbustFile(filen_in, filen_out, debug) catch |err| {
        try std.testing.expect(err == img.StbImageError.IOReadError);
    };
}

test "md5 checksums" {
    const in = test_dir_path ++ sep ++ "minimal.jpg";
    const out = test_dir_path ++ sep ++ "minimal_out.jpg";
    try setup();
    try img.icbustFile(in, out, debug);
    const alloc = std.testing.allocator;
    var hash1: [16]u8 = undefined;
    try md5File(alloc, in, &hash1);
    var hash2: [16]u8 = undefined;
    try md5File(alloc, out, &hash2);

    if (debug) {
        std.debug.print("md5 => {s}\n", .{std.fmt.fmtSliceHexLower(&hash1)});
        std.debug.print("md5 => {s}\n", .{std.fmt.fmtSliceHexLower(&hash2)});
    }

    try std.testing.expect(std.mem.eql(u8, hash1[0..], hash2[0..]) == false);
    try teardown();
}
